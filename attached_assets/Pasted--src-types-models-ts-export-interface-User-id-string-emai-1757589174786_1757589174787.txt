// ============== src/types/models.ts ==============
export interface User {
  id: string;
  email: string;
  fullName?: string;
  phone?: string;
  userType: 'diner' | 'owner';
  avatarUrl?: string;
  bio?: string;
  createdAt: string;
  updatedAt: string;
}

export interface Restaurant {
  id: string;
  ownerId: string;
  name: string;
  description?: string;
  cuisineTypes: string[];
  address: string;
  city: string;
  phone: string;
  email: string;
  rating: number;
  reviewCount: number;
  priceRange: 1 | 2 | 3 | 4;
  images: string[];
  coverImage: string;
  amenities: string[];
  businessHours: BusinessHours;
  isVerified: boolean;
  createdAt: string;
  location: {
    latitude: number;
    longitude: number;
  };
}

export interface BusinessHours {
  [key: string]: {
    open: string;
    close: string;
    isClosed: boolean;
  };
}

export interface Booking {
  id: string;
  userId: string;
  restaurantId: string;
  bookingDate: string;
  bookingTime: string;
  partySize: number;
  status: 'pending' | 'approved' | 'declined' | 'completed' | 'cancelled' | 'closed';
  specialRequests?: string;
  tableSection?: string;
  createdAt: string;
  restaurant?: Restaurant;
  user?: User;
}

export interface Review {
  id: string;
  userId: string;
  restaurantId: string;
  bookingId?: string;
  rating: number;
  comment?: string;
  images?: string[];
  createdAt: string;
  user?: User;
}

export interface Category {
  id: string;
  name: string;
  image: string;
  icon: string;
}

export interface Notification {
  id: string;
  userId: string;
  type: 'booking' | 'review' | 'promotion' | 'social';
  title: string;
  message: string;
  data?: any;
  isRead: boolean;
  createdAt: string;
}

export interface OwnerStats {
  totalViews: number;
  totalImpressions: number;
  weeklyViews: number[];
  monthlyBookings: number;
  averageRating: number;
  growthPercentage: number;
}

// ============== src/types/api.ts ==============
export interface ApiResponse<T> {
  data: T | null;
  error: string | null;
  success: boolean;
}

export interface PaginatedResponse<T> {
  data: T[];
  count: number;
  page: number;
  totalPages: number;
}

export interface SearchFilters {
  category?: string;
  priceRange?: number[];
  rating?: number;
  distance?: number;
  amenities?: string[];
}

// ============== src/lib/supabase.ts ==============
import { createClient } from '@supabase/supabase-js';
import AsyncStorage from '@react-native-async-storage/async-storage';

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// ============== src/lib/storage.ts ==============
import { supabase } from './supabase';

export class StorageService {
  static async uploadImage(file: any, bucket: string, path: string): Promise<string | null> {
    try {
      const { data, error } = await supabase.storage
        .from(bucket)
        .upload(path, file);

      if (error) throw error;

      const { data: { publicUrl } } = supabase.storage
        .from(bucket)
        .getPublicUrl(data.path);

      return publicUrl;
    } catch (error) {
      console.error('Upload error:', error);
      return null;
    }
  }

  static async deleteImage(bucket: string, path: string): Promise<boolean> {
    try {
      const { error } = await supabase.storage
        .from(bucket)
        .remove([path]);

      return !error;
    } catch (error) {
      console.error('Delete error:', error);
      return false;
    }
  }
}

// ============== src/lib/notifications.ts ==============
import * as Notifications from 'expo-notifications';
import { Platform } from 'react-native';

Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: false,
    shouldSetBadge: false,
  }),
});

export class NotificationService {
  static async registerForPushNotifications(): Promise<string | null> {
    let token = null;

    if (Platform.OS === 'android') {
      await Notifications.setNotificationChannelAsync('default', {
        name: 'default',
        importance: Notifications.AndroidImportance.MAX,
        vibrationPattern: [0, 250, 250, 250],
        lightColor: '#FF231F7C',
      });
    }

    const { status: existingStatus } = await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;

    if (existingStatus !== 'granted') {
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }

    if (finalStatus !== 'granted') {
      alert('Failed to get push token for push notification!');
      return null;
    }

    token = (await Notifications.getExpoPushTokenAsync()).data;
    return token;
  }

  static async scheduleLocalNotification(title: string, body: string, data?: any) {
    await Notifications.scheduleNotificationAsync({
      content: {
        title,
        body,
        data,
      },
      trigger: { seconds: 2 },
    });
  }
}

// ============== src/store/authStore.ts ==============
import { create } from 'zustand';
import { User } from '@/types/models';

interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  userType: 'diner' | 'owner' | null;
  selectedRole: 'diner' | 'owner' | null;
  setUser: (user: User | null) => void;
  setLoading: (loading: boolean) => void;
  setSelectedRole: (role: 'diner' | 'owner' | null) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  isLoading: true,
  isAuthenticated: false,
  userType: null,
  selectedRole: null,
  setUser: (user) =>
    set({
      user,
      isAuthenticated: !!user,
      userType: user?.userType || null,
    }),
  setLoading: (isLoading) => set({ isLoading }),
  setSelectedRole: (selectedRole) => set({ selectedRole }),
  logout: () =>
    set({
      user: null,
      isAuthenticated: false,
      userType: null,
      selectedRole: null,
    }),
}));

// ============== src/store/uiStore.ts ==============
import { create } from 'zustand';

interface UIState {
  theme: 'light' | 'dark';
  language: 'en' | 'fr' | 'es';
  isBottomSheetOpen: boolean;
  activeTab: string;
  searchQuery: string;
  selectedCategory: string | null;
  toggleTheme: () => void;
  setLanguage: (language: 'en' | 'fr' | 'es') => void;
  setBottomSheetOpen: (isOpen: boolean) => void;
  setActiveTab: (tab: string) => void;
  setSearchQuery: (query: string) => void;
  setSelectedCategory: (category: string | null) => void;
}

export const useUIStore = create<UIState>((set) => ({
  theme: 'dark',
  language: 'en',
  isBottomSheetOpen: false,
  activeTab: 'home',
  searchQuery: '',
  selectedCategory: null,
  toggleTheme: () => set((state) => ({ theme: state.theme === 'light' ? 'dark' : 'light' })),
  setLanguage: (language) => set({ language }),
  setBottomSheetOpen: (isBottomSheetOpen) => set({ isBottomSheetOpen }),
  setActiveTab: (activeTab) => set({ activeTab }),
  setSearchQuery: (searchQuery) => set({ searchQuery }),
  setSelectedCategory: (selectedCategory) => set({ selectedCategory }),
}));

// ============== src/hooks/useTheme.ts ==============
import { useUIStore } from '@/store/uiStore';

export const useTheme = () => {
  const { theme, toggleTheme } = useUIStore();

  const colors = {
    light: {
      background: '#FFFFFF',
      surface: '#F8F9FA',
      text: '#2C3E50',
      textSecondary: '#7F8C8D',
      primary: '#E67E22',
      border: '#E1E1E1',
      card: '#FFFFFF',
    },
    dark: {
      background: '#1A1A1A',
      surface: '#2C2C2C',
      text: '#FFFFFF',
      textSecondary: '#BDC3C7',
      primary: '#E67E22',
      border: '#3A3A3A',
      card: '#2C2C2C',
    },
  };

  return {
    theme,
    colors: colors[theme],
    toggleTheme,
  };
};

// ============== src/components/Button.tsx ==============
import React from 'react';
import {
  TouchableOpacity,
  Text,
  StyleSheet,
  ActivityIndicator,
  ViewStyle,
  TextStyle,
} from 'react-native';
import { useTheme } from '@/hooks/useTheme';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  style?: ViewStyle;
  textStyle?: TextStyle;
  fullWidth?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  title,
  onPress,
  variant = 'primary',
  size = 'medium',
  disabled = false,
  loading = false,
  style,
  textStyle,
  fullWidth = false,
}) => {
  const { colors } = useTheme();

  const styles = StyleSheet.create({
    base: {
      borderRadius: 12,
      alignItems: 'center',
      justifyContent: 'center',
      borderWidth: 1,
      borderColor: 'transparent',
      width: fullWidth ? '100%' : undefined,
    },
    primary: {
      backgroundColor: colors.primary,
    },
    secondary: {
      backgroundColor: colors.surface,
    },
    outline: {
      backgroundColor: 'transparent',
      borderColor: colors.primary,
    },
    ghost: {
      backgroundColor: 'transparent',
    },
    small: {
      paddingVertical: 8,
      paddingHorizontal: 16,
    },
    medium: {
      paddingVertical: 12,
      paddingHorizontal: 24,
    },
    large: {
      paddingVertical: 16,
      paddingHorizontal: 32,
    },
    disabled: {
      backgroundColor: colors.border,
      borderColor: colors.border,
    },
    text: {
      fontWeight: '600',
      fontSize: 16,
    },
    primaryText: {
      color: '#FFFFFF',
    },
    secondaryText: {
      color: colors.text,
    },
    outlineText: {
      color: colors.primary,
    },
    ghostText: {
      color: colors.primary,
    },
  });

  return (
    <TouchableOpacity
      style={[
        styles.base,
        styles[variant],
        styles[size],
        disabled && styles.disabled,
        style,
      ]}
      onPress={onPress}
      disabled={disabled || loading}
      activeOpacity={0.8}
    >
      {loading ? (
        <ActivityIndicator
          color={variant === 'primary' ? '#FFFFFF' : colors.primary}
          size="small"
        />
      ) : (
        <Text style={[styles.text, styles[`${variant}Text`], textStyle]}>
          {title}
        </Text>
      )}
    </TouchableOpacity>
  );
};

// ============== src/components/Input.tsx ==============
import React, { useState } from 'react';
import {
  TextInput,
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ViewStyle,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '@/hooks/useTheme';

interface InputProps {
  label?: string;
  placeholder?: string;
  value: string;
  onChangeText: (text: string) => void;
  secureTextEntry?: boolean;
  keyboardType?: 'default' | 'email-address' | 'numeric' | 'phone-pad';
  error?: string;
  style?: ViewStyle;
  leftIcon?: string;
  rightIcon?: string;
  onRightIconPress?: () => void;
  multiline?: boolean;
  numberOfLines?: number;
  editable?: boolean;
}

export const Input: React.FC<InputProps> = ({
  label,
  placeholder,
  value,
  onChangeText,
  secureTextEntry = false,
  keyboardType = 'default',
  error,
  style,
  leftIcon,
  rightIcon,
  onRightIconPress,
  multiline = false,
  numberOfLines = 1,
  editable = true,
}) => {
  const { colors } = useTheme();
  const [isPasswordVisible, setIsPasswordVisible] = useState(!secureTextEntry);

  const styles = StyleSheet.create({
    container: {
      marginBottom: 16,
    },
    label: {
      fontSize: 14,
      fontWeight: '600',
      color: colors.text,
      marginBottom: 8,
    },
    inputContainer: {
      flexDirection: 'row',
      alignItems: 'center',
      borderWidth: 1,
      borderColor: error ? '#E74C3C' : colors.border,
      borderRadius: 12,
      paddingHorizontal: 16,
      backgroundColor: colors.surface,
      minHeight: 50,
    },
    input: {
      flex: 1,
      fontSize: 16,
      color: colors.text,
      paddingVertical: 12,
    },
    icon: {
      marginRight: 12,
    },
    rightIcon: {
      marginLeft: 12,
    },
    error: {
      fontSize: 12,
      color: '#E74C3C',
      marginTop: 4,
    },
  });

  const handlePasswordToggle = () => {
    setIsPasswordVisible(!isPasswordVisible);
  };

  return (
    <View style={[styles.container, style]}>
      {label && <Text style={styles.label}>{label}</Text>}
      <View style={styles.inputContainer}>
        {leftIcon && (
          <Ionicons
            name={leftIcon as any}
            size={20}
            color={colors.textSecondary}
            style={styles.icon}
          />
        )}
        <TextInput
          style={styles.input}
          placeholder={placeholder}
          placeholderTextColor={colors.textSecondary}
          value={value}
          onChangeText={onChangeText}
          secureTextEntry={secureTextEntry && !isPasswordVisible}
          keyboardType={keyboardType}
          multiline={multiline}
          numberOfLines={numberOfLines}
          editable={editable}
        />
        {secureTextEntry && (
          <TouchableOpacity onPress={handlePasswordToggle} style={styles.rightIcon}>
            <Ionicons
              name={isPasswordVisible ? 'eye-off' : 'eye'}
              size={20}
              color={colors.textSecondary}
            />
          </TouchableOpacity>
        )}
        {rightIcon && !secureTextEntry && (
          <TouchableOpacity onPress={onRightIconPress} style={styles.rightIcon}>
            <Ionicons
              name={rightIcon as any}
              size={20}
              color={colors.textSecondary}
            />
          </TouchableOpacity>
        )}
      </View>
      {error && <Text style={styles.error}>{error}</Text>}
    </View>
  );
};

// ============== src/components/Card.tsx ==============
import React from 'react';
import { View, StyleSheet, ViewStyle } from 'react-native';
import { useTheme } from '@/hooks/useTheme';

interface CardProps {
  children: React.ReactNode;
  style?: ViewStyle;
  padding?: number;
  margin?: number;
}

export const Card: React.FC<CardProps> = ({
  children,
  style,
  padding = 16,
  margin = 0,
}) => {
  const { colors } = useTheme();

  const styles = StyleSheet.create({
    card: {
      backgroundColor: colors.card,
      borderRadius: 12,
      padding,
      margin,
      shadowColor: '#000',
      shadowOffset: {
        width: 0,
        height: 2,
      },
      shadowOpacity: 0.1,
      shadowRadius: 3.84,
      elevation: 5,
    },
  });

  return <View style={[styles.card, style]}>{children}</View>;
};

// ============== src/components/Avatar.tsx ==============
import React from 'react';
import { Image, View, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '@/hooks/useTheme';

interface AvatarProps {
  source?: { uri: string };
  size?: number;
  onPress?: () => void;
  showEditIcon?: boolean;
}

export const Avatar: React.FC<AvatarProps> = ({
  source,
  size = 50,
  onPress,
  showEditIcon = false,
}) => {
  const { colors } = useTheme();

  const styles = StyleSheet.create({
    container: {
      position: 'relative',
    },
    avatar: {
      width: size,
      height: size,
      borderRadius: size / 2,
      backgroundColor: colors.surface,
    },
    placeholder: {
      width: size,
      height: size,
      borderRadius: size / 2,
      backgroundColor: colors.surface,
      alignItems: 'center',
      justifyContent: 'center',
    },
    editIcon: {
      position: 'absolute',
      bottom: 0,
      right: 0,
      backgroundColor: colors.primary,
      width: 20,
      height: 20,
      borderRadius: 10,
      alignItems: 'center',
      justifyContent: 'center',
    },
  });

  const AvatarComponent = (
    <View style={styles.container}>
      {source?.uri ? (
        <Image source={source} style={styles.avatar} />
      ) : (
        <View style={styles.placeholder}>
          <Ionicons name="person" size={size * 0.5} color={colors.textSecondary} />
        </View>
      )}
      {showEditIcon && (
        <View style={styles.editIcon}>
          <Ionicons name="pencil" size={12} color="#FFFFFF" />
        </View>
      )}
    </View>
  );

  if (onPress) {
    return (
      <TouchableOpacity onPress={onPress} activeOpacity={0.8}>
        {AvatarComponent}
      </TouchableOpacity>
    );
  }

  return AvatarComponent;
};

// ============== src/components/Loader.tsx ==============
import React from 'react';
import { View, ActivityIndicator, StyleSheet, Text } from 'react-native';
import { useTheme } from '@/hooks/useTheme';

interface LoaderProps {
  size?: 'small' | 'large';
  text?: string;
  fullScreen?: boolean;
}

export const Loader: React.FC<LoaderProps> = ({
  size = 'large',
  text,
  fullScreen = false,
}) => {
  const { colors } = useTheme();

  const styles = StyleSheet.create({
    container: {
      alignItems: 'center',
      justifyContent: 'center',
      padding: 20,
    },
    fullScreen: {
      ...StyleSheet.absoluteFillObject,
      backgroundColor: colors.background,
    },
    text: {
      marginTop: 16,
      fontSize: 16,
      color: colors.textSecondary,
      textAlign: 'center',
    },
  });

  return (
    <View style={[styles.container, fullScreen && styles.fullScreen]}>
      <ActivityIndicator size={size} color={colors.primary} />
      {text && <Text style={styles.text}>{text}</Text>}
    </View>
  );
};

// ============== src/features/auth/hooks/useAuth.ts ==============
import { useAuthStore } from '@/store/authStore';
import { supabase } from '@/lib/supabase';
import { User } from '@/types/models';
import { ApiResponse } from '@/types/api';

export const useAuth = () => {
  const { user, isLoading, setUser, setLoading, logout } = useAuthStore();

  const signIn = async (email: string, password: string): Promise<ApiResponse<User>> => {
    setLoading(true);
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', data.user.id)
        .single();

      const userProfile: User = {
        id: data.user.id,
        email: data.user.email!,
        fullName: profile?.full_name,
        phone: profile?.phone,
        userType: profile?.user_type,
        avatarUrl: profile?.avatar_url,
        bio: profile?.bio,
        createdAt: profile?.created_at,
        updatedAt: profile?.updated_at,
      };

      setUser(userProfile);
      return { data: userProfile, error: null, success: true };
    } catch (error: any) {
      return { data: null, error: error.message, success: false };
    } finally {
      setLoading(false);
    }
  };

  const signUp = async (
    email: string,
    password: string,
    userData: {
      fullName: string;
      userType: 'diner' | 'owner';
      phone?: string;
    }
  ): Promise<ApiResponse<User>> => {
    setLoading(true);
    try {
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
      });

      if (error) throw error;

      if (data.user) {
        const { error: profileError } = await supabase
          .from('profiles')
          .insert({
            id: data.user.id,
            full_name: userData.fullName,
            user_type: userData.userType,
            phone: userData.phone,
          });

        if (profileError) throw profileError;

        const userProfile: User = {
          id: data.user.id,
          email: data.user.email!,
          fullName: userData.fullName,
          phone: userData.phone,
          userType: userData.userType,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };

        return { data: userProfile, error: null, success: true };
      }

      return { data: null, error: 'Failed to create user', success: false };
    } catch (error: any) {
      return { data: null, error: error.message, success: false };
    } finally {
      setLoading(false);
    }
  };

  const signOut = async () => {
    await supabase.auth.signOut();
    logout();
  };

  const resetPassword = async (email: string): Promise<ApiResponse<void>> => {
    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email);
      if (error) throw error;
      return { data: null, error: null, success: true };
    } catch (error: any) {
      return { data: null, error: error.message, success: false };
    }
  };

  return {
    user,
    isLoading,
    signIn,
    signUp,
    signOut,
    resetPassword,
  };
};

// ============== src/features/auth/screens/WelcomeScreen.tsx ==============
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  ImageBackground,
  SafeAreaView,
  StatusBar,
} from 'react-native';
import { Button } from '@/components/Button';
import { useAuthStore } from '@/store/authStore';

export const WelcomeScreen = () => {
  const { setSelectedRole } = useAuthStore();

  return (
    <>
      <StatusBar barStyle="light-content" />
      <ImageBackground
        source={{
          uri: 'https://images.unsplash.com/photo-1517248135467-4c7edcad34c4?ixlib=rb-4.0.3&auto=format&fit=crop&w=2340&q=80',
        }}
        style={styles.background}
      >
        <SafeAreaView style={styles.container}>
          <View style={styles.overlay}>
            <View style={styles.content}>
              <View style={styles.logoContainer}>
                <Text style={styles.logo}>JAW</Text>
              </View>
              
              <Text style={styles.title}>Welcome to JAW</Text>
              <Text style={styles.subtitle}>
                Your complete restaurant discovery platform
              </Text>

              <View style={styles.buttonContainer}>
                <Button
                  title="I'm looking for restaurants"
                  onPress={() => setSelectedRole('diner')}
                  variant="primary"
                  size="large"
                  fullWidth
                  style={styles.button}
                />

                <Button
                  title="I'm a restaurant owner"
                  onPress={() => setSelectedRole('owner')}
                  variant="outline"
                  size="large"
                  fullWidth
                  style={[styles.button, styles.outlineButton]}
                  textStyle={styles.outlineButtonText}
                />
              </View>
            </View>
          </View>
        </SafeAreaView>
      </ImageBackground>
    </>
  );
};

const styles = StyleSheet.create({
  background: {
    flex: 1,
  },
  container: {
    flex: 1,
  },
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  content: {
    width: '100%',
    maxWidth: 400,
    alignItems: 'center',
  },
  logoContainer: {
    marginBottom: 40,
  },
  logo: {
    fontSize: 64,
    fontWeight: 'bold',
    color: '#FFFFFF',
    letterSpacing: 4,
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#FFFFFF',
    textAlign: 'center',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#FFFFFF',
    textAlign: 'center',
    marginBottom: 60,
    opacity: 0.9,
    lineHeight: 22,
  },
  buttonContainer: {
    width: '100%',
    gap: 16,
  },
  button: {
    height: 56,
  },
  outlineButton: {
    borderColor: '#FFFFFF',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
  },
  outlineButtonText: {
    color: '#FFFFFF',
  },
});

// ============== src/features/auth/screens/SignInScreen.tsx ==============
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  TouchableOpacity,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { Input } from '@/components/Input';
import { Button } from '@/components/Button';
import { useAuth } from '../hooks/useAuth';
import { useTheme } from '@/hooks/useTheme';
import { useAuthStore } from '@/store/authStore';

export const SignInScreen = ({ navigation }: any) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState<{ email?: string; password?: string }>({});
  
  const { signIn, isLoading } = useAuth();
  const { colors } = useTheme();
  const { selectedRole, setSelectedRole } = useAuthStore();

  const validateForm = () => {
    const newErrors: { email?: string; password?: string } = {};

    if (!email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      newErrors.email = 'Email is invalid';
    }

    if (!password.trim()) {
      newErrors.password = 'Password is required';
    } else if (password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };